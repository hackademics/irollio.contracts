// SPDX-License-Identifier: MIT
pragma solidity >=0.4.22 <0.9.0;
pragma experimental ABIEncoderV2;

import "../iRollio.sol";
import "../lib/Structs.sol";
import "@chainlink/contracts/src/v0.6/VRFConsumerBase.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/math/SafeMath.sol";
import "@openzeppelin/contracts/utils/Address.sol";

contract RollService is Ownable, VRFConsumerBase {
    
	using SafeMath for uint256;
	using SafeMath for int8;
	using Address  for address;

    uint8[5]  public   dice;
    address   private  caller;
    bool      private  locked;
    bytes32   internal vrfHash;
    uint256   internal vrfFee;
    bytes32   internal vrfRequestId;
    uint8     internal dc = 5;
    uint8     internal ds = 6;

    Roll private roll;

    event VRFRequest(address sender, Roll roll);
    event VRFResponse(address sender, Roll roll);
    
    /**
     * Constructor inherits VRFConsumerBase
     * 
     * Network: Kovan
     * Chainlink VRF Coordinator address: 0xdD3782915140c8f3b190B5D67eAc6dc5760C46E9
     * LINK token address:                0xa36085F69e2889c224210F603D836748e7dC0088
     * Key Hash: 0x6c3699283bda56ad74f6b855546325b68d482e983852a7a82979cc4807b641f4
     */
    constructor(address _linkTokenAddress) public VRFConsumerBase(0xdD3782915140c8f3b190B5D67eAc6dc5760C46E9, _linkTokenAddress )
    {
        vrfHash = 0x6c3699283bda56ad74f6b855546325b68d482e983852a7a82979cc4807b641f4;
        vrfFee = 0.1 * 10 ** 18; // 0.1 LINK
    }
    
    /** 
        @dev Request random number from VRF
        @param _roll Current Roll
    */
    function request(Roll memory _roll) public {
        require(vrfHash != bytes32(0), "Invalid Key Hash");
        require(!locked, "VRF Locked");
        require(_roll.seed > 0, "Invalid User Seed");

        lock();
            caller = msg.sender; 
            roll = _roll;                  
            roll.vrfId = requestRandomness(vrfHash, vrfFee, _roll.seed);        
            emit VRFRequest(caller, roll);
        unlock();
    }

    /**
        @dev Callback funtion from VRF
        @param _id Request Id sent by VRF
        @param _num Random Number generated by VRF
     */
    function fulfillRandomness(bytes32 _id , uint256 _num) internal override { 
        require(_id != bytes32(0), "Invalid Request Id");
        require(roll.vrfId == _id, "Invalid VRF Request Id");
        
        roll.vrfNum = _num;
        
        modDice(roll);        

        emit VRFResponse(caller, roll);
        
        //CALL BACK 
        iRollio(caller).rollResult(roll);
        
        
    }  

    /**
        @dev Use division and mod to pull required dice from random number
        @param _roll Current Roll
     */
    function modDice(Roll memory _roll) internal view {
        require(_roll.vrfNum > 0, "Invalid Random Number");

        uint8 d = 0;
        for (uint8 i = 0; i < (dc - 1); i++) {
            _roll.dice[i] = uint8((_roll.vrfNum / d) % ds + 1);
            d = d == 0 ? 10 : uint8(d*d);
        }
    } 

    /**
        @dev Admin Lock the contract 
     */
    function lock() public onlyOwner {
        locked = true;
    }

    /**
        @dev Admin Unlock contract
     */
    function unlock() public onlyOwner {
        locked = false;
    }

    /** 
        @dev Get Chainlink token
     */
    function getChainlinkToken() public view returns (address) { return address(LINK); }



}